= Documentation v0.3 â€“ Gestion des demandes et les recherche optimisÃ©s
v0.3, Janvier 2025
:pdf-theme: default
:pdf-fontsdir: GEMS_DIR/asciidoctor-pdf/data/fonts
:pdf-page-size: A4
:pdf-page-layout: portrait
:pdf-scripts: scripts
:toc:
:toc-title: Sommaire

== ğŸ¯ Introduction

La version v0.3 marque une avancÃ©e majeure pour lâ€™application en intÃ©grant un **systÃ¨me de notifications en temps rÃ©el**, une **gestion fluide des demandes dâ€™intÃ©rÃªt**, et une **expÃ©rience utilisateur optimisÃ©e**.

Cette documentation couvre :

. Les nouvelles fonctionnalitÃ©s dÃ©veloppÃ©es.
. Les **flux utilisateurs** pour chaque action clÃ©.
. Les **endpoints backend** utilisÃ©s.
. Lâ€™**impact mÃ©tier** et la valeur ajoutÃ©e des amÃ©liorations.
. Un **diagramme de sÃ©quence UML** pour illustrer le workflow.

---

== ğŸš€ Grandes FonctionnalitÃ©s

=== ğŸ“Œ 2.1 Gestion des Demandes d'IntÃ©rÃªt & Notifications en Temps RÃ©el

**Description**

Cette fonctionnalitÃ© regroupe tout le flux des demandes d'intÃ©rÃªt, y compris les notifications en temps rÃ©el. Les utilisateurs peuvent envoyer et recevoir des demandes d'intÃ©rÃªt, puis Ãªtre notifiÃ©s de l'acceptation ou du refus de la demande en temps rÃ©el.

**Flux Utilisateur**

1. **Envoi d'une Demande d'IntÃ©rÃªt**
    - L'utilisateur intÃ©ressÃ© clique sur "Demander".
    - La demande est enregistrÃ©e en base (via **POST /interests**).
    - Une notification en temps rÃ©el est envoyÃ©e au proposeur.
2. **Consultation des Demandes d'IntÃ©rÃªt**
    - Le proposeur accÃ¨de Ã  "Mes IntÃ©rÃªts ReÃ§us".
    - Il voit la demande et peut lâ€™accepter ou la refuser.
3. **Notifications et Actions en Temps RÃ©el**
    - Si la demande est acceptÃ©e, le demandeur est notifiÃ© avec les coordonnÃ©es du proposeur.
    - Si la demande est refusÃ©e, le demandeur est informÃ© de la dÃ©cision.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **POST** | `/interests` | CrÃ©er une demande dâ€™intÃ©rÃªt.
| **GET** | `/interests/received/:userId` | RÃ©cupÃ©rer les demandes reÃ§ues.
| **GET** | `/interests/sent/:userId` | RÃ©cupÃ©rer les demandes envoyÃ©es.
| **PUT** | `/interests/:id` | Accepter ou refuser une demande.
| **GET** | `/notifications/:userId` | RÃ©cupÃ¨re toutes les notifications dâ€™un utilisateur.
| **POST** | `/notifications` | CrÃ©e une nouvelle notification.
| **DELETE** | `/notifications/:notifId` | Supprime une notification spÃ©cifique.
| **DELETE** | `/notifications/all/:userId` | Supprime toutes les notifications dâ€™un utilisateur.
|===

**Diagramme de SÃ©quence : Demande d'IntÃ©rÃªt et Notifications**
[plantuml, demande-notification-sequence, svg]
----
@startuml
participant "Utilisateur IntÃ©ressÃ© (par l'annonce)" as UI
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB
participant "WebSockets" as WS
participant "Proposeur (de l'annonce)" as P

== ğŸ“© 1. L'utilisateur envoie une demande dâ€™intÃ©rÃªt ==
UI -> FE: Clique sur "Demander"
FE -> API: **POST** /interests (proposition_id, interested_user_id)
API -> DB: ğŸ” VÃ©rifie que la proposition existe
DB --> API: âœ… OK
API -> DB: ğŸ“ Enregistre la demande avec statut **"pending"**
DB --> API: âœ… OK (id_interet)
API -> WS: ğŸ“¡ **Ã‰met une notification au proposeur**
WS --> P: ğŸ”” "Nouvelle demande reÃ§ue"

== ğŸ“¥ 2. Le proposeur consulte ses demandes ==
P -> FE: AccÃ¨de Ã  "Mes IntÃ©rÃªts ReÃ§us"
FE -> API: **GET** /interests/received/:userId
API -> DB: ğŸ” RÃ©cupÃ¨re toutes les demandes associÃ©es Ã  lâ€™utilisateur
DB --> API: ğŸ“‹ Renvoie les demandes (id, titre, utilisateur intÃ©ressÃ©)
API --> FE: ğŸ–¥ï¸ Affiche la liste des demandes

== âœ… 3A. Le proposeur **accepte** la demande ==
P -> FE: Clique sur "**Accepter**"
FE -> API: **PUT** /interests/:id (status: accepted)
API -> DB: âœ… Met Ã  jour le statut en **"accepted"**
DB --> API: âœ… OK
API -> WS: ğŸ“¡ **Ã‰met une notification avec le statut acceptÃ©**
WS --> UI: ğŸ”” "**ğŸ‰ Votre demande a Ã©tÃ© acceptÃ©e ! Voici les contacts ğŸ“§ğŸ“**"

== âŒ 3B. Le proposeur **refuse** la demande ==
P -> FE: Clique sur "**Refuser**"
FE -> API: **PUT** /interests/:id (status: rejected)
API -> DB: âŒ Met Ã  jour le statut en **"rejected"**
DB --> API: âœ… OK
API -> WS: ğŸ“¡ **Ã‰met une notification avec le statut refusÃ©**
WS --> UI: ğŸ”” "**âŒ Votre demande a Ã©tÃ© refusÃ©e.**"
@enduml
----

---

=== ğŸ“Œ 2.2 Recherche de Propositions

**Description**

Cette fonctionnalitÃ© permet aux utilisateurs de rechercher des propositions en fonction de plusieurs critÃ¨res : mots-clÃ©s, catÃ©gorie et distance gÃ©ographique.

**Flux Utilisateur**

1. L'utilisateur entre des mots-clÃ©s et sÃ©lectionne une catÃ©gorie de service.
2. Le systÃ¨me effectue une recherche floue sur les titres et descriptions des propositions.
3. Le systÃ¨me filtre les propositions par catÃ©gorie sÃ©lectionnÃ©e.
4. Le systÃ¨me calcule la distance gÃ©ographique entre l'utilisateur et les propositions.
5. Les rÃ©sultats sont affichÃ©s, triÃ©s par proximitÃ© gÃ©ographique.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `/propositions/search` | Recherche des propositions en fonction des mots-clÃ©s, catÃ©gorie et distance.
|===

**Diagramme de SÃ©quence : Recherche de Propositions**
[plantuml, recherche-sequence, svg]
----
@startuml
actor "Utilisateur" as User
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB
participant "Fuse.js" as Fuse
participant "WebSocket (si notifications)" as WS

== 1. L'utilisateur effectue une recherche ==
User -> FE: Entre des mots-clÃ©s et sÃ©lectionne une catÃ©gorie
FE -> API: **GET** /propositions/search (mots-clÃ©s, catÃ©gorie, utilisateur_id)
API -> DB: ğŸ” RÃ©cupÃ¨re les propositions en fonction de la catÃ©gorie
DB --> API: ğŸ“‹ Liste des propositions filtrÃ©es par catÃ©gorie
API -> Fuse: Utilise Fuse.js pour recherche floue sur 'title' et 'description'
Fuse --> API: ğŸ“‹ Liste des propositions correspondant aux mots-clÃ©s
API -> DB: ğŸ” RÃ©cupÃ¨re les coordonnÃ©es de l'utilisateur (latitude, longitude)
DB --> API: ğŸ“‹ CoordonnÃ©es de l'utilisateur
API -> DB: ğŸ” Calcule la distance entre l'utilisateur et chaque proposition
DB --> API: ğŸ“‹ Liste des propositions avec distances
API -> FE: ğŸ–¥ï¸ Affiche les rÃ©sultats avec distance et pertinence
FE --> User: Montre les propositions filtrÃ©es

@enduml
----

=== ğŸ“Œ 2.3 Recherche AvancÃ©e des Ã‰vÃ©nements

**Description**

Cette fonctionnalitÃ© permet aux utilisateurs de rechercher des Ã©vÃ©nements en fonction de plusieurs critÃ¨res : mots-clÃ©s, catÃ©gorie et ville. GrÃ¢ce Ã  la bibliothÃ¨que **Fuse.js**, la recherche est floue et permet de retrouver des Ã©vÃ©nements qui correspondent partiellement aux mots-clÃ©s recherchÃ©s, mÃªme en cas d'erreur de frappe.

Le processus de recherche est optimisÃ© pour une expÃ©rience utilisateur fluide :

1. L'utilisateur saisit un mot-clÃ© (et optionnellement, sÃ©lectionne une catÃ©gorie ou une ville).
2. Le systÃ¨me filtre les Ã©vÃ©nements en fonction de la catÃ©gorie et de la ville sÃ©lectionnÃ©es.
3. La recherche floue est effectuÃ©e sur les titres et descriptions des Ã©vÃ©nements en utilisant Fuse.js, avec un seuil de pertinence rÃ©glable pour affiner les rÃ©sultats.
4. Les rÃ©sultats sont retournÃ©s et triÃ©s par pertinence.

**Flux Utilisateur**

1. L'utilisateur entre un mot-clÃ© de recherche et, si souhaitÃ©, sÃ©lectionne une catÃ©gorie et/ou une ville.
2. La recherche floue est effectuÃ©e dans les titres et descriptions des Ã©vÃ©nements.
3. Les Ã©vÃ©nements sont filtrÃ©s en fonction de la catÃ©gorie et de la ville, si spÃ©cifiÃ©s.
4. Les rÃ©sultats de recherche sont retournÃ©s, affichÃ©s par pertinence.
5. L'utilisateur peut cliquer sur un Ã©vÃ©nement pour consulter son dÃ©tail.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `api/events/search` | Recherche des Ã©vÃ©nements en fonction des mots-clÃ©s, catÃ©gorie et ville.
| **GET** | `api/events/:id` | RÃ©cupÃ¨re les dÃ©tails dâ€™un Ã©vÃ©nement spÃ©cifique.
|===

**Diagramme de SÃ©quence : Recherche AvancÃ©e des Ã‰vÃ©nements**
[plantuml, recherche-avancee-sequence, svg]
----
@startuml
actor "Utilisateur" as User
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB
participant "Fuse.js" as Fuse

== 1. L'utilisateur effectue une recherche ==
User -> FE: Saisit un mot-clÃ© et sÃ©lectionne une catÃ©gorie ou une ville
FE -> API: **GET** api//events/search (mot-clÃ©, catÃ©gorie, ville)
API -> DB: ğŸ” RÃ©cupÃ¨re tous les Ã©vÃ©nements en fonction de la catÃ©gorie et de la ville
DB --> API: ğŸ“‹ Liste des Ã©vÃ©nements filtrÃ©s
API -> Fuse: Recherche floue sur 'title' et 'description'
Fuse --> API: ğŸ“‹ Liste des Ã©vÃ©nements correspondant aux mots-clÃ©s
API -> FE: ğŸ–¥ï¸ Affiche les rÃ©sultats de la recherche
FE --> User: Montre les Ã©vÃ©nements filtrÃ©s par pertinence

== 2. L'utilisateur consulte un Ã©vÃ©nement ==
User -> FE: Clique sur un Ã©vÃ©nement
FE -> API: **GET** api/events/:id
API -> DB: ğŸ” RÃ©cupÃ¨re les dÃ©tails de lâ€™Ã©vÃ©nement avec lâ€™ID
DB --> API: ğŸ“‹ DÃ©tails de lâ€™Ã©vÃ©nement
API -> FE: ğŸ–¥ï¸ Affiche les dÃ©tails de lâ€™Ã©vÃ©nement
FE --> User: Montre les dÃ©tails de lâ€™Ã©vÃ©nement

@enduml
----
=== ğŸ“Œ 2.4 Modification et Suppression des Ã‰vÃ©nements

**Description**

Les utilisateurs peuvent dÃ©sormais **modifier** ou **supprimer** leurs Ã©vÃ©nements Ã  partir de lâ€™interface. Cela permet une gestion complÃ¨te des Ã©vÃ©nements, incluant l'actualisation ou la suppression de donnÃ©es obsolÃ¨tes.

**Flux Utilisateur**

1. **Modification**
   - Lâ€™utilisateur ouvre les dÃ©tails de son Ã©vÃ©nement.
   - Il clique sur le bouton "**Modifier**".
   - Un formulaire prÃ©-rempli sâ€™affiche avec les informations actuelles.
   - AprÃ¨s modification, il clique sur "**Enregistrer**" pour sauvegarder les modifications.

2. **Suppression**
   - Lâ€™utilisateur ouvre les dÃ©tails de son Ã©vÃ©nement.
   - Il clique sur le bouton "**Supprimer**".
   - Une confirmation sâ€™affiche avant suppression dÃ©finitive.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **PUT** | `/api/events/:id` | Met Ã  jour un Ã©vÃ©nement existant.
| **DELETE** | `/api/events/:id` | Supprime un Ã©vÃ©nement spÃ©cifique.
|===

**Diagramme de SÃ©quence : Modification et Suppression des Ã‰vÃ©nements**
[plantuml, modification-suppression-evenements, svg]
----
@startuml
actor "Utilisateur" as User
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB

== 1. Modification ==
User -> FE: Ouvre les dÃ©tails de l'Ã©vÃ©nement
FE -> API: **GET** /api/events/:id
API -> DB: RÃ©cupÃ¨re les donnÃ©es de l'Ã©vÃ©nement
DB --> API: Renvoie les donnÃ©es de l'Ã©vÃ©nement
API --> FE: Affiche les dÃ©tails
User -> FE: Clique sur "Modifier" et enregistre les modifications
FE -> API: **PUT** /api/events/:id (modifications)
API -> DB: Met Ã  jour l'Ã©vÃ©nement
DB --> API: Confirme la mise Ã  jour
API --> FE: Notifie le succÃ¨s de la modification

== 2. Suppression ==
User -> FE: Clique sur "Supprimer"
FE -> API: **DELETE** /api/events/:id
API -> DB: Supprime l'Ã©vÃ©nement
DB --> API: Confirme la suppression
API --> FE: Notifie le succÃ¨s de la suppression
@enduml
----

---

== ğŸš€ Petites FonctionnalitÃ©s

=== ğŸ“Œ 2.1 Page â€œMes Demandes EnvoyÃ©esâ€ ğŸ“¤

**Description**

Ajout dâ€™une nouvelle section permettant aux utilisateurs de **suivre leurs demandes** et voir si elles sont **acceptÃ©es ou refusÃ©es**.

**Flux Utilisateur**

1. Lâ€™utilisateur consulte **la section â€œMes demandes envoyÃ©esâ€**.
2. Il voit **toutes ses demandes** avec leur statut actuel.
3. **Si la demande est acceptÃ©e**, il accÃ¨de aux **coordonnÃ©es du proposeur**.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `/interests/sent/:userId` | Retourne les demandes envoyÃ©es par lâ€™utilisateur.
| **PUT** | `/interests/:id` | Met Ã  jour le statut dâ€™une demande.
|===

---

=== ğŸ“Œ 2.2 Notifications en Temps RÃ©el ğŸ””

**Description**

Les notifications sont envoyÃ©es en temps rÃ©el Ã  lâ€™utilisateur lorsquâ€™une action importante se produit (acceptation/refus dâ€™une demande, etc.). Cela permet une interaction fluide et rÃ©active avec lâ€™application.

**Flux Utilisateur**

1. Lâ€™utilisateur effectue une action qui gÃ©nÃ¨re une notification.
2. Une notification apparaÃ®t instantanÃ©ment dans le panneau des notifications.
3. Lâ€™utilisateur peut la consulter et la supprimer.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **POST** | `/notifications` | CrÃ©e une nouvelle notification.
| **GET** | `/notifications/:userId` | RÃ©cupÃ¨re toutes les notifications dâ€™un utilisateur.
| **DELETE** | `/notifications/:notifId` | Supprime une notification spÃ©cifique.
| **DELETE** | `/notifications/all/:userId` | Supprime toutes les notifications dâ€™un utilisateur.
|===

---

=== ğŸ“Œ 2.3 DÃ©tails dâ€™un Ã‰vÃ©nement

**Description**

Les utilisateurs peuvent dÃ©sormais visualiser les dÃ©tails dâ€™un Ã©vÃ©nement. Cette page affiche les informations complÃ¨tes de lâ€™Ã©vÃ©nement sÃ©lectionnÃ©, comme son titre, sa description, sa date, son lieu, sa catÃ©gorie, et son image associÃ©e.

**Flux Utilisateur**

1. Lâ€™utilisateur clique sur un Ã©vÃ©nement dans la liste des Ã©vÃ©nements.
2. Une fenÃªtre modale sâ€™affiche, contenant les dÃ©tails complets de lâ€™Ã©vÃ©nement.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `/api/events/:id` | RÃ©cupÃ¨re les dÃ©tails dâ€™un Ã©vÃ©nement spÃ©cifique.
|===

---

=== ğŸ“Œ 2.4 Gestion des Images des Ã‰vÃ©nements (Frontend)

**Description**

La prise en charge des images dâ€™Ã©vÃ©nements a Ã©tÃ© ajoutÃ©e dans :
- Le formulaire de crÃ©ation et de modification des Ã©vÃ©nements.
- La page de dÃ©tails des Ã©vÃ©nements.

Les utilisateurs peuvent visualiser une image par dÃ©faut (si aucune image nâ€™est fournie) ou une image personnalisÃ©e associÃ©e Ã  lâ€™Ã©vÃ©nement.

**Flux Utilisateur**

1. Lors de la crÃ©ation ou modification dâ€™un Ã©vÃ©nement, lâ€™utilisateur peut spÃ©cifier lâ€™URL dâ€™une image.
2. Si lâ€™utilisateur ne renseigne pas dâ€™image, une image par dÃ©faut est utilisÃ©e.
3. La page de dÃ©tails affiche lâ€™image associÃ©e Ã  lâ€™Ã©vÃ©nement.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `/api/events/:id` | RÃ©cupÃ¨re les dÃ©tails de lâ€™Ã©vÃ©nement, y compris lâ€™URL de lâ€™image.
| **POST** | `/api/events` | Permet de crÃ©er un Ã©vÃ©nement avec une image associÃ©e.
| **PUT** | `/api/events/:id` | Permet de modifier lâ€™image associÃ©e Ã  un Ã©vÃ©nement.
| **GET** |`/api/validate-image` | Permet de vÃ©rifier si une URL dâ€™image est valide.
|===

---

=== ğŸ“Œ 2.5 Filtre par Villes

**Description**

Un filtre par villes a Ã©tÃ© ajoutÃ© pour permettre aux utilisateurs de rechercher des Ã©vÃ©nements en fonction de leur localisation.

**Flux Utilisateur**

1. Lâ€™utilisateur sÃ©lectionne une ville dans la liste dÃ©roulante des filtres.
2. Les Ã©vÃ©nements affichÃ©s sont automatiquement filtrÃ©s pour correspondre Ã  la ville sÃ©lectionnÃ©e.

**Endpoints Backend**
|===
| MÃ©thode | Endpoint | Description
| **GET** | `/cities` | RÃ©cupÃ¨re les villes disponibles pour les Ã©vÃ©nements.
|===

**Note :** Les filtres sont appliquÃ©s cÃ´tÃ© frontend en combinant les critÃ¨res de recherche pour offrir une expÃ©rience utilisateur optimale.

---


=== ğŸ“Œ 2.6 AmÃ©liorations UX/UI ğŸ¨

Lâ€™application a Ã©tÃ© **remaniÃ©e graphiquement** pour une **meilleure expÃ©rience utilisateur** :

* âœ… **Nouvelle navbar fixe** avec **navigation fluide**.
* âœ… **Popup de notifications stylÃ©e** avec **mise en forme propre**.
* âœ… **Suppression du bleu flashy** et **adoption dâ€™un design plus Ã©purÃ©**.
* âœ… **Animations CSS** pour un rendu **plus dynamique**.
* âœ… **Espacement et marges ajustÃ©s** pour **une meilleure lisibilitÃ©**.

---
== ğŸ“Š Impact MÃ©tier & Valeur AjoutÃ©e

|===
| FonctionnalitÃ© | Valeur AjoutÃ©e
| ğŸ”” Notifications en temps rÃ©el | Permet aux utilisateurs dâ€™Ãªtre informÃ©s instantanÃ©ment des actions importantes.
| ğŸ“© Gestion des demandes dâ€™intÃ©rÃªt | Simplifie lâ€™interaction entre utilisateurs, rendant le processus plus intuitif.
| ğŸ“¤ Suivi des demandes envoyÃ©es | Apporte de la transparence sur lâ€™Ã©tat des interactions.
| ğŸ¨ ExpÃ©rience utilisateur amÃ©liorÃ©e | Favorise lâ€™adoption de la plateforme grÃ¢ce Ã  une interface plus intuitive et agrÃ©able.
| ğŸ§ Recherche avancÃ©e des Ã©vÃ©nements | Permet une recherche rapide et prÃ©cise des Ã©vÃ©nements grÃ¢ce Ã  la recherche floue, mÃªme avec des erreurs typographiques.
|===

== âœ… Tests & Validation

* **Notifications en temps rÃ©el** : Fonctionnent sans latence.
* **Gestion des statuts (pending, accepted, rejected)** : Bien mise Ã  jour en base.
* **UI et UX fluides** : Interface rÃ©active et intuitive.


== Documentation v1.0 â€“ Signalement de dangers
v1.0, FÃ©vrier 2025
:toc:
:toc-title: Sommaire

== ğŸ¯ Introduction

La fonctionnalitÃ© de **signalement de dangers** permet aux utilisateurs de **remonter en temps rÃ©el des incidents** dans leur quartier. Cette feature repose sur un **workflow rapide** et efficace pour assurer une rÃ©activitÃ© maximale. 

ğŸš€ **Objectif** : Offrir une plateforme oÃ¹ les rÃ©sidents peuvent signaler **instantanÃ©ment** des problÃ¨mes de sÃ©curitÃ© et autres nuisances, avec **des notifications en temps rÃ©el** via WebSockets.

**Pourquoi cette feature ?**
- ğŸ¡ **Faciliter la communication locale** : les utilisateurs peuvent informer leurs voisins dâ€™un danger potentiel.
- â³ **RÃ©activitÃ© immÃ©diate** : les signalements sont visibles immÃ©diatement et les dangers critiques envoient une notification.
- ğŸ“ **AmÃ©lioration de la sÃ©curitÃ©** : plus de transparence et de rÃ©activitÃ© sur les incidents urbains.

---

== âš™ï¸ FonctionnalitÃ©s

**ğŸ“Œ 1. Section Signalement rapide**
-Via un formulaire dÃ©diÃ©, les utilisateurs peuvent signaler un problÃ¨me en quelques clics :
- SÃ©lection dâ€™une **catÃ©gorie** parmi : 
  * **ğŸš¨ Dangers & SÃ©curitÃ©** (vol, bagarre, accidentâ€¦)
  * **ğŸš ProblÃ¨mes Urbains** (routes endommagÃ©es, lampadaires HSâ€¦)
  * **ğŸ”Š Nuisances Sonores** (fÃªte bruyante, klaxonsâ€¦)
  * **ğŸš— ProblÃ¨mes de stationnement** (vÃ©hicule gÃªnant, parking saturÃ©â€¦)
- Description courte et **zone du quartier** concernÃ©e.
- Option ğŸš¨ **Critique** : Si activÃ© par l'utilisateur lors de la saisie du formulaire, on envoie une notification immÃ©diate aux rÃ©sidents.

**ğŸ“Œ 2. Section pour l'affichage des signalements**
- ğŸ¯ Les **5 derniers signalements** sont visibles sur le **Dashboard**, mis Ã  jour en temps rÃ©el.
- ğŸ“‹ A l'aide d'un bouton "voir plus", l'utilisateur peut voir en dÃ©tail tous les signalements qui ont Ã©tÃ© faits, sur la **page dÃ©diÃ©e aux signalements**.

**ğŸ“Œ 3. Ajout de notifications WebSockets pour signaler le danger**
- **Si le signalement est critique**, une notification en **temps rÃ©el** est envoyÃ©e Ã  **tous les utilisateurs**.
- **Mise Ã  jour automatique** du compteur de notifications.
- **Pas besoin de recharger la page** : le signalement et les notifs sont **instantanÃ©ment visibles**, ce qui permet Ã  l'utilisateur de recevoir l'information sans faire d'effort particulier.

**ğŸ“Œ 4. Section Mes signalements**
- Les utilisateurs peuvent consulter **tous leurs signalements** passÃ©s.
- **Marquer un signalement comme rÃ©solu** pour indiquer que le problÃ¨me a Ã©tÃ© traitÃ©.
- Synchronisation avec la liste globale : Si lâ€™alerte est rÃ©solue, elle apparaÃ®t aussi comme â€œrÃ©solueâ€ pour tous.

---

== ğŸ”„ **Workflow du signalement de danger**

[plantuml, signalement_sequence, svg]
----
@startuml
participant "Utilisateur" as UI
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB
participant "WebSockets" as WS
participant "Autres utilisateurs" as USERS

== ğŸ“© 1. Signalement dâ€™un danger ==
UI -> FE: Remplit le formulaire et valide
FE -> API: **POST** /signalements (catÃ©gorie, description, critiqueâ€¦)
API -> DB: ğŸ” Enregistre le signalement
DB --> API: âœ… OK

== ğŸš¨ 2. Notification en temps rÃ©el si critique ==
API -> WS: ğŸ“¡ **Ã‰mettre une notification Ã  tous les utilisateurs**
WS --> USERS: ğŸ”” **Notification "ProblÃ¨me signalÃ©"**
USERS -> FE: **Mise Ã  jour immÃ©diate du compteur de notifications**

== ğŸ“¢ 3. Mise Ã  jour du tableau de bord ==
API -> WS: **Mise Ã  jour "Derniers signalements"**
WS --> FE: ğŸ“¡ Mettre Ã  jour **sans recharger** ğŸ”„

== ğŸ‘¤ 4. Gestion des signalements ==
UI -> FE: AccÃ¨de Ã  "ğŸ“œ Mes signalements"
FE -> API: **GET** /signalements/utilisateur/{user_id}
API -> DB: ğŸ” RÃ©cupÃ¨re les signalements de lâ€™utilisateur
DB --> API: ğŸ“‹ Renvoie la liste
API --> FE: Affichage des signalements

== âœ… 5. Marquer un signalement comme rÃ©solu ==
UI -> FE: Clique sur "âœ”ï¸ Marquer comme rÃ©solu"
FE -> API: **PUT** /signalements/:id/resoudre
API -> DB: âœ… Met Ã  jour le statut "RÃ©solu"
DB --> API: **OK**

@enduml
----

---

== ğŸ›  **DÃ©tails Techniques**

ğŸ“Œ **Base de donnÃ©es**
- **Table `signalements`** :
  * `id` (INT, PRIMARY KEY)
  * `user_id` (INT, FOREIGN KEY vers `users`)
  * `categorie` (ENUM)
  * `description` (TEXT)
  * `critique` (BOOLEAN)
  * `quartier` (TEXT)
  * `resolu` (BOOLEAN, DEFAULT FALSE)
  * `date_creation` (DATETIME, DEFAULT CURRENT_TIMESTAMP)

- **Table `notifications`** (ajout du type `danger_alert`)
  * `id`
  * `user_id`
  * `type` (ENUM)
  * `message`
  * `related_entity_id`
  * `created_at`

ğŸ“Œ **Backend API (Node.js, Express, MySQL)**
- **POST** `/signalements` â†’ CrÃ©e un nouveau signalement
- **GET** `/signalements` â†’ RÃ©cupÃ¨re tous les signalements
- **PUT** `/signalements/:id/resoudre` â†’ Marque un signalement comme rÃ©solu
- **WebSockets** : Notification temps rÃ©el via `io.emit("notification-global", {...})`

ğŸ“Œ **Frontend (React)**
- **Composants**
  * `SignalementForm.jsx` â†’ Formulaire de signalement
  * `SignalementsList.jsx` â†’ Affichage des signalements
  * `Dashboard.jsx` â†’ IntÃ©gration des signalements rÃ©cents
  * `Notifications.jsx` â†’ Gestion des alertes en temps rÃ©el

---

== ğŸ“¸ **Illustrations**
ğŸ“Œ **Wireframe**
image::images/wireframe_signalement.png[]

ğŸ“Œ **Capture dâ€™Ã©cran du site**
image::images/signalements_dashboard.png[]

---

== ğŸ“Š Comparaison avec les plateformes existantes

Notre solution se distingue par son approche **temps rÃ©el** et son **interface ultra-rÃ©active**. Voici comment elle se positionne face aux alternatives existantes :

[options="header"]
|===
| Plateforme | Type de signalement | InstantanÃ©itÃ© des mises Ã  jour | Notifications aux rÃ©sidents | Suivi des signalements

| *AlloVoisins / Nextdoor*
| Discussions entre voisins, annonces de services
| âŒ Non (les publications sont statiques)
| âŒ Non (les notifications concernent uniquement des interactions sociales)
| âŒ Non (pas de suivi des incidents)

| *DansMaRue (Paris)*
| Signalements urbains (voirie, Ã©clairage public, etc.)
| âŒ Non (validation requise par la mairie)
| âŒ Non (aucune notification directe aux citoyens)
| âœ… Oui (suivi possible aprÃ¨s traitement)

| *FixMyStreet*
| ProblÃ¨mes dâ€™infrastructure (routes, mobilier urbain)
| âŒ Non (mises Ã  jour manuelles)
| âŒ Non (seules les autoritÃ©s locales reÃ§oivent les alertes)
| âœ… Oui (gestion par les services municipaux)

| *Notre application* ğŸš€
| Dangers, nuisances et incidents du quotidien
| âœ… *Oui* (mise Ã  jour automatique en temps rÃ©el)
| âœ… *Oui* (alerte immÃ©diate aux rÃ©sidents en cas de danger critique)
| âœ… *Oui* (gestion et rÃ©solution directe par les utilisateurs)
|===

== ğŸ† Pourquoi nous sommes innovants ?

ğŸ’¡ **RapiditÃ© & InstantanÃ©itÃ©**  
Notre solution utilise **les WebSockets** pour une mise Ã  jour immÃ©diate des signalements et une **notification instantanÃ©e** aux rÃ©sidents.

ğŸš€ **Autonomie des utilisateurs**  
Lâ€™utilisateur **peut signaler, suivre et clÃ´turer un incident** sans intervention administrative.

ğŸ”” **Notifications intelligentes**  
Seuls les signalements *critiques* dÃ©clenchent une alerte pour Ã©viter le spam tout en maintenant un haut niveau de rÃ©activitÃ©.

ğŸ–¥ **ExpÃ©rience utilisateur optimisÃ©e**  
Interface fluide, ergonomique et conÃ§ue pour une utilisation rapide **depuis un mobile ou un desktop**.

Notre application comble un **manque majeur** dans la gestion des signalements en quartiers : **lâ€™instantanÃ©itÃ© et lâ€™autonomie des citoyens**.

ğŸ“ **Conclusion** : Contrairement Ã  dâ€™autres plateformes, notre application offre **une communication rapide, directe et communautaire**.

---

== âœ… **Tests rÃ©alisÃ©s**
- **Tests unitaires** : VÃ©rification du bon enregistrement dâ€™un signalement en base.
- **Tests dâ€™intÃ©gration** : Simulation dâ€™une notification critique et validation de son affichage en WebSockets.
- **Tests REST API** (Postman) :
  * Envoi dâ€™un signalement â†’ **200 OK**
  * Marquer un signalement comme rÃ©solu â†’ **200 OK**
  * RÃ©cupÃ©ration des notifications en temps rÃ©el â†’ **âœ… Fonctionnel**

---

== ğŸš€ **Conclusion**
ğŸ¯ **Bilan de la feature** :
- **InstantanÃ©itÃ© & efficacitÃ©** avec **WebSockets**.
- **ExpÃ©rience utilisateur fluide** (mise Ã  jour automatique des signalements et notifications).
- **ModularitÃ© & Ã©volutivitÃ©** (possibilitÃ© dâ€™ajouter des filtres par quartier, historique des signalementsâ€¦).

ğŸ”¥ **Prochaines amÃ©liorations possibles** :
- Ajouter une **cartographie** interactive des signalements.
- Permettre aux utilisateurs de **commenter et rÃ©agir** aux signalements.
- **Statistiques** sur les types de signalements les plus frÃ©quents.
- Ajouter le temps rÃ©el pour dire Ã  tous les utilisateurs qu'un signalement est dÃ©sormais terminÃ©.

---

ğŸš€ **Feature livrÃ©e avec succÃ¨s !** ğŸ‰







== ğŸ“Œ Documentation v1.0 â€“ Gestion des Projets

=== **Description**  
Cette fonctionnalitÃ© introduit la gestion complÃ¨te des projets au sein de lâ€™application.  
Les utilisateurs peuvent **crÃ©er, modifier et supprimer** des projets communautaires, voter pour un projet et suivre leur Ã©volution.  
Les projets sont **rattachÃ©s aux quartiers** pour favoriser des initiatives locales et renforcer lâ€™engagement des rÃ©sidents.

---

=== **Flux Utilisateur**  

. **CrÃ©ation dâ€™un Projet**  
  * Lâ€™utilisateur clique sur **â€œ+ CrÃ©er un projetâ€**.  
  * Il remplit un formulaire comprenant : **titre, description, catÃ©gorie, date limite**.  
  * Le projet est automatiquement **associÃ© au quartier** de lâ€™utilisateur.  
  * Une fois validÃ©, le projet apparaÃ®t dans la liste des projets de son quartier.  

. **Affichage des Projets**  
  * Par dÃ©faut, seuls les **projets du quartier** de lâ€™utilisateur sont affichÃ©s.  
  * Une case Ã  cocher **"Afficher tous les projets"** permet de voir **lâ€™ensemble des projets** disponibles.  

. **DÃ©tails dâ€™un Projet**  
  * Un utilisateur peut **cliquer sur un projet** pour voir ses dÃ©tails complets (crÃ©ateur, description, votes, date limite).  
  * Si lâ€™utilisateur est le crÃ©ateur du projet, il peut **le modifier ou le supprimer**.  

. **Modification dâ€™un Projet** *(seulement pour le crÃ©ateur)*  
  * Lâ€™utilisateur accÃ¨de aux dÃ©tails de son projet et clique sur **â€œModifierâ€**.  
  * Un **formulaire prÃ©-rempli** lui permet de mettre Ã  jour les informations.  
  * AprÃ¨s validation, les modifications sont **enregistrÃ©es en base** et **affichÃ©es en temps rÃ©el**.  

. **Suppression dâ€™un Projet** *(seulement pour le crÃ©ateur)*  
  * Lâ€™utilisateur clique sur **â€œSupprimerâ€**.  
  * Une **confirmation** sâ€™affiche pour Ã©viter toute suppression accidentelle.  
  * Le projet est dÃ©finitivement supprimÃ©.  

. **Votes sur un Projet**  
  * Les utilisateurs peuvent **voter pour ou contre** un projet (**ğŸ‘ Upvote** ou **ğŸ‘ Downvote**).  
  * Un utilisateur **ne peut pas voter pour son propre projet**.  
  * Les votes sont **mis Ã  jour en temps rÃ©el** sans rechargement de la page.  
  * Une fois la pÃ©riode de votes terminÃ©e, un projet est **acceptÃ© ou rejetÃ©** en fonction du nombre de votes positifs/nÃ©gatifs.  

---

=== **Endpoints Backend**
[options="header"]
|===
| MÃ©thode | Endpoint | Description  
| **POST** | `/api/projects` | CrÃ©er un projet  
| **GET** | `/api/projects` | RÃ©cupÃ©rer tous les projets (avec option quartier/tous les projets)  
| **GET** | `/api/projects/:id` | RÃ©cupÃ©rer les dÃ©tails dâ€™un projet  
| **PUT** | `/api/projects/:id` | Modifier un projet *(seulement si lâ€™utilisateur est le crÃ©ateur)*  
| **DELETE** | `/api/projects/:id` | Supprimer un projet *(seulement si lâ€™utilisateur est le crÃ©ateur)*  
| **POST** | `/api/projects/:id/vote` | Voter pour un projet *(ğŸ‘ / ğŸ‘)*  
|===  

---

=== **Diagramme de SÃ©quence : Gestion des Projets**
[plantuml, gestion-projets-sequence, svg]
----
@startuml
actor "Utilisateur" as User
participant "Frontend (React)" as FE
participant "Backend API" as API
participant "Base de DonnÃ©es" as DB

== ğŸ“Œ 1. CrÃ©ation dâ€™un Projet ==
User -> FE: Clique sur "CrÃ©er un projet"
FE -> API: **POST** /api/projects (titre, description, catÃ©gorie, deadline, quartier_id)
API -> DB: ğŸ” VÃ©rifie les donnÃ©es et insÃ¨re le projet
DB --> API: âœ… OK (id_projet)
API --> FE: Confirme la crÃ©ation et met Ã  jour la liste des projets

== ğŸ“Œ 2. Affichage des Projets ==
User -> FE: AccÃ¨de Ã  la page "Projets"
FE -> API: **GET** /api/projects?quartier_id=X
API -> DB: ğŸ” RÃ©cupÃ¨re les projets du quartier
DB --> API: ğŸ“‹ Liste des projets filtrÃ©s
API --> FE: Affichage des projets

== ğŸ“Œ 3. Modification dâ€™un Projet ==
User -> FE: Ouvre son projet et clique sur "Modifier"
FE -> API: **PUT** /api/projects/:id (nouvelles valeurs)
API -> DB: âœ… Met Ã  jour le projet
DB --> API: ğŸ“‹ Confirme la mise Ã  jour
API --> FE: Affichage des nouvelles valeurs

== ğŸ“Œ 4. Suppression dâ€™un Projet ==
User -> FE: Clique sur "Supprimer"
FE -> API: **DELETE** /api/projects/:id
API -> DB: âŒ Supprime le projet
DB --> API: âœ… Suppression confirmÃ©e
API --> FE: Met Ã  jour la liste des projets

== ğŸ“Œ 5. Vote sur un Projet ==
User -> FE: Clique sur "ğŸ‘" ou "ğŸ‘"
FE -> API: **POST** /api/projects/:id/vote (vote=up/down, user_id)
API -> DB: ğŸ” VÃ©rifie si lâ€™utilisateur a dÃ©jÃ  votÃ©
DB --> API: âœ… OK
API -> DB: ğŸ“ Met Ã  jour le vote
DB --> API: ğŸ“‹ Retourne le nouveau compteur de votes
API --> FE: Affichage des votes mis Ã  jour

@enduml
----

---

=== ğŸ“Š Impact MÃ©tier & Valeur AjoutÃ©e
[options="header"]
|===
| FonctionnalitÃ© | Valeur AjoutÃ©e  
| ğŸ¡ *Projets rattachÃ©s aux quartiers* | Favorise les initiatives locales et renforce le lien social.  
| âœ… *Gestion complÃ¨te (CRUD)* | Permet aux utilisateurs de crÃ©er, modifier et supprimer leurs projets en toute autonomie.  
| ğŸ‘ğŸ‘ *Votes en temps rÃ©el* | Donne un retour direct sur lâ€™intÃ©rÃªt du projet auprÃ¨s de la communautÃ©.  
| ğŸ”¥ *VisibilitÃ© optimisÃ©e* | Les projets sont mis en avant selon leur popularitÃ© et leur pertinence.  
|===  

---

=== **âœ… Tests & Validation**
- **Tests unitaires** :  
  * CrÃ©ation, modification et suppression dâ€™un projet â†’ âœ… OK  
  * Votes sur un projet â†’ âœ… OK  

- **Tests dâ€™intÃ©gration** :  
  * Validation de lâ€™affichage des projets filtrÃ©s par quartier â†’ âœ… Fonctionnel  
  * Test de lâ€™option "Afficher tous les projets" â†’ âœ… Fonctionnel  

- **Tests REST API (Postman)** :  
  * `POST /api/projects` â†’ **201 Created**  
  * `GET /api/projects` (avec quartier_id) â†’ **200 OK**  
  * `PUT /api/projects/:id` (modification) â†’ **200 OK**  
  * `DELETE /api/projects/:id` â†’ **200 OK**  
  * `POST /api/projects/:id/vote` â†’ **200 OK**  

---

=== **ğŸš€ Conclusion**
ğŸ¯ **Bilan de la feature :**  
- âœ… CrÃ©ation et gestion des projets **simple et fluide**  
- âœ… **Filtrage intelligent** des projets selon le quartier  
- âœ… **SystÃ¨me de votes participatif** pour la validation des projets  
- âœ… **Interface optimisÃ©e et ergonomique**  

ğŸ”¥ **Prochaines amÃ©liorations possibles :**  
- Ajout dâ€™une **gestion des tÃ¢ches** par projet (Kanban).  
- SystÃ¨me de **commentaires** sur les projets.  
- Ajout dâ€™un **statut de projet** (`En cours`, `TerminÃ©`, etc.).  

ğŸš€ **Feature livrÃ©e avec succÃ¨s !** ğŸ‰



== Documentation Technique â€“ Release v1.1 - DevOps2


== Objectif de la fonctionnalitÃ©

Permettre aux utilisateurs de :

1. Se connecter Ã  leur compte Google via un bouton dÃ©diÃ©.
2. Visualiser leurs Ã©vÃ©nements Google Calendar dans le dashboard de la plateforme.
3. Ajouter automatiquement un Ã©vÃ©nement Ã  leur Google Calendar lorsqu'ils cliquent sur le bouton â€œParticiperâ€ Ã  un Ã©vÃ©nement.

Cette intÃ©gration offre une expÃ©rience fluide et connectÃ©e, Ã©vitant aux utilisateurs dâ€™avoir Ã  gÃ©rer manuellement leur emploi du temps aprÃ¨s sâ€™Ãªtre inscrits Ã  un Ã©vÃ©nement.

== ğŸš€ NouveautÃ© cÃ´tÃ© utilisateur

Avant cette release, lâ€™utilisateur ne pouvait ni sâ€™inscrire Ã  un Ã©vÃ©nement, ni le quitter, et aucune synchronisation nâ€™existait avec son agenda personnel.

Avec cette intÃ©gration, il peut dÃ©sormais :

- Participer ou quitter un Ã©vÃ©nement local directement depuis lâ€™interface KnockNShare ;
- Ajouter automatiquement cet Ã©vÃ©nement Ã  son propre Google Calendar (avec lieu, date, heure, description) ;
- Et surtout, visualiser en temps rÃ©el ses Ã©vÃ©nements Google, y compris ceux ajoutÃ©s via KnockNShare, depuis le dashboard de lâ€™application.

Cette avancÃ©e rapproche la plateforme dâ€™un vÃ©ritable assistant de vie communautaire connectÃ©, conforme Ã  notre vision de simplification des interactions sociales au sein des quartiers.

== ğŸ§± FonctionnalitÃ©s livrÃ©es

- Connexion OAuth2.0 Ã  Google (frontend) avec affichage des Ã©vÃ©nements Ã  venir.
- Ajout automatique dâ€™un Ã©vÃ©nement Google Calendar lors du clic sur "Participer".
- Conservation du token dâ€™accÃ¨s dans un contexte React (`GoogleAuthContext`) avec mise Ã  jour automatique.
- Bouton â€œParticiperâ€ fonctionnel : interaction avec la base de donnÃ©es + appel API Google Calendar.



== Authentification Google (OAuth2) â€“ IntÃ©gration initiale

=== Objectif

Permettre aux utilisateurs de se connecter Ã  KnockNShare via leur compte Google, sans avoir Ã  crÃ©er un compte ou Ã  renseigner un mot de passe.
Cette Ã©tape est Ã©galement un prÃ©requis technique Ã  lâ€™intÃ©gration du calendrier Google.

=== FonctionnalitÃ©s livrÃ©es

* Redirection de lâ€™utilisateur vers la page dâ€™authentification Google.
* DÃ©codage du `id_token` pour obtenir les donnÃ©es de base (`email`, `name`, `google_id`).
* VÃ©rification de lâ€™existence de lâ€™utilisateur en base, crÃ©ation automatique si inexistant.
* GÃ©nÃ©ration dâ€™un JWT signÃ©, transmis au frontend via redirection.
* Stockage du `userId` et de lâ€™`access_token` dans le `localStorage` (clÃ© `googleAccessToken`) pour les requÃªtes vers lâ€™API Calendar.

=== ImplÃ©mentation technique

==== Backend (Node.js/Express)

* Ajout des routes suivantes :

[source]
GET  /api/auth/google           // redirection vers Google
GET  /api/auth/google/callback  // traitement du code + crÃ©ation/utilisateur

* Ajout du scope :
[source,js]
scope: "openid profile email https://www.googleapis.com/auth/calendar.readonly"

* DÃ©codage du `id_token` avec `jsonwebtoken`, gÃ©nÃ©ration dâ€™un JWT interne avec `userId`, `email`, etc.
* Enregistrement des utilisateurs Google en base (table `users`) avec `google_id`, sans mot de passe.

==== Frontend (React)

* Ajout dâ€™un bouton â€œSe connecter avec Googleâ€ sur la page de connexion (`LoginPage.jsx`).
* Ajout dâ€™une page `OAuthSuccess.jsx` qui :

  * lit le `token` et lâ€™`access_token` dans lâ€™URL,
  * les stocke dans `localStorage`,
  * met Ã  jour lâ€™`AuthContext`,
  * redirige lâ€™utilisateur vers le dashboard.

=== Migration SQL associÃ©e

Ajout de la colonne `google_id` dans la table `users` et passage de `password` en nullable :

[source,sql]

ALTER TABLE users ADD COLUMN google\_id VARCHAR(255);
ALTER TABLE users MODIFY COLUMN password VARCHAR(255) NULL;

Fichier de migration : `update_users_schema.sql`

=== Configuration

Ajout des variables suivantes dans le fichier `.env` :

[source]

GOOGLE\_CLIENT\_ID=...
GOOGLE\_CLIENT\_SECRET=...
GOOGLE\_CALLBACK\_URL=http://localhost:3000/api/auth/google/callback


Le `access_token` Google est dÃ©sormais stockÃ© dans le navigateur et peut Ãªtre utilisÃ© par les autres fonctionnalitÃ©s (ex : synchronisation Calendar).




== IntÃ©gration Google Calendar â€“ DÃ©tails techniques

=== 1. Authentification OAuth

Le composant `GoogleAuthProvider.jsx` initialise et configure `gapi.auth2` :

- RÃ©cupÃ¨re et stocke le token.
- Ã‰coute les connexions/dÃ©connexions avec `auth.isSignedIn.listen`.
- Expose `signIn()` et `token` via `GoogleAuthContext`.

Scope utilisÃ© :

[source,js]
----
const SCOPES = "https://www.googleapis.com/auth/calendar.events";
----

=== 2. Affichage des Ã©vÃ©nements Google (dashboard)

Dans `Dashboard.jsx` :

- Le bouton *Connecter Google Calendar* lance `signIn()`.
- Si un `token` est prÃ©sent, les Ã©vÃ©nements sont rÃ©cupÃ©rÃ©s via :

[source,js]
----
gapi.client.calendar.events.list({...})
----

- Le composant `DashboardCalendar.jsx` affiche ces Ã©vÃ©nements.

=== 3. CrÃ©ation dâ€™Ã©vÃ©nement Ã  la participation

Dans `EventPage.jsx`, lors du clic sur *Participer* :

- Ajout du participant via :
[source]
----
POST /api/events/participate
----

- CrÃ©ation dâ€™un Ã©vÃ©nement Google Calendar :

[source,js]
----
POST https://www.googleapis.com/calendar/v3/calendars/primary/events
Headers: Authorization: Bearer access_token
----

Payload envoyÃ© :

[source,json]
----
{
  "summary": "Titre",
  "description": "Description",
  "location": "Adresse",
  "start": { "dateTime": "...", "timeZone": "Europe/Paris" },
  "end": { "dateTime": "...", "timeZone": "Europe/Paris" }
}
----

=== 4. Backend (routes Node/Express)

[source]
----
POST   /api/events/participate   // ajoute Ã  participants
DELETE /api/events/leave         // supprime de participants
----

Gestion de la base MySQL avec vÃ©rification des doublons.

== Architecture technique

|===
| Composant/Fichier         | RÃ´le

| `GoogleAuthProvider.jsx` | GÃ¨re lâ€™authentification OAuth et expose le token
| `Dashboard.jsx`          | Affiche les Ã©vÃ©nements et dÃ©clenche la connexion
| `DashboardCalendar.jsx`  | Affiche les Ã©vÃ©nements Google Calendar
| `EventPage.jsx`          | GÃ¨re la logique de participation + ajout Google Calendar
| `/api/events/participate`| Backend : enregistre la participation
| `/api/events/leave`      | Backend : supprime la participation
|===

== ProblÃ¨mes rencontrÃ©s

- **Expiration du token** : contournÃ©e avec Ã©coute `isSignedIn` dans le contexte
- **Client ID multiple** : risque de conflit, Ã  sÃ©curiser dans un `.env`.
- **Perte de session inter-composant** : rÃ©solue avec `GoogleAuthContext`.

==  BÃ©nÃ©fices de cette feature dans la stratÃ©gie globale de notre application

Cette fonctionnalitÃ© amÃ©liore considÃ©rablement lâ€™expÃ©rience utilisateur :

- Meilleure expÃ©rience pour l'utilisateur : automatisation de lâ€™ajout dâ€™Ã©vÃ©nements, la participation est plus simple et rapide, et apparaÃ®t dans le calendrier personnel de l'utilisateur
  -Gain de temps â†’ plus besoin de noter lâ€™Ã©vÃ©nement dans un agenda externe.
  -Moins dâ€™oubli â†’ les rappels automatiques Google sâ€™appliquent.
  -Notre plateforme KnockNshare devient un vrai outil dâ€™organisation de vie communautaire.


== Tests rÃ©alisÃ©s

- Connexion OAuth fonctionnelle.
- Visualisation des Ã©vÃ©nements dans le calendrier.
- Ajout dâ€™un Ã©vÃ©nement fonctionnel avec token valide.
- DÃ©connexion/reconnexion gÃ©rÃ©e automatiquement.

== Release v1.1 â€“ RÃ©capitulatif

- IntÃ©gration complÃ¨te OAuth (Google Calendar)
- Ajout automatique dâ€™Ã©vÃ©nements
- Visualisation des Ã©vÃ©nements Google
- Reconnexion et gestion de session
- Base backend synchronisÃ©e




== KnockNshare â€“ Release Notes v1.2


== Objectif de la version

Cette version vise Ã  amÃ©liorer lâ€™expÃ©rience de mise en relation entre les utilisateurs Ã  travers lâ€™intÃ©gration dâ€™une API externe (Telegram), en facilitant la communication entre prÃªteur et emprunteur, tout en assurant une suppression automatique des conversations terminÃ©es.

== 1. IntÃ©gration dâ€™une API externe : Telegram

=== 1.1. Objectif

Faciliter les Ã©changes entre le demandeur (intÃ©ressÃ©) et le proposeur en offrant une option de contact via Telegram, en complÃ©ment de lâ€™email et du numÃ©ro de tÃ©lÃ©phone.

=== 1.2. Fonctionnement
	â€¢	Lorsquâ€™un intÃ©rÃªt est acceptÃ©, le proposeur peut dÃ©sormais contacter lâ€™utilisateur intÃ©ressÃ© via Telegram si ce dernier a renseignÃ© son nom dâ€™utilisateur Telegram.
	â€¢	Le lien de contact est gÃ©nÃ©rÃ© dynamiquement (https://t.me/<username>) et affichÃ© dans la vue Mes IntÃ©rÃªts ReÃ§us aux cÃ´tÃ©s des coordonnÃ©es classiques.
	â€¢	Ce lien ouvre automatiquement Telegram (application mobile ou version web) et initie une conversation avec lâ€™utilisateur ciblÃ©.
	â€¢	Si Telegram est installÃ© sur le smartphone ou lâ€™ordinateur, lâ€™ouverture se fait de maniÃ¨re fluide sans configuration supplÃ©mentaire.

=== 1.3. Contraintes techniques
	â€¢	Pas dâ€™identification OAuth2 Telegram.
	â€¢	Il n'Ã©tait pas possible de crÃ©er un groupe entre 2 utilisateurs sans qu'ils n'aient exÃ©cutÃ© la commande /start avec notre bot.

=== 1.4. Avantages
	â€¢	Respecte la vie privÃ©e : lâ€™utilisateur choisit dâ€™Ãªtre contactÃ© par Telegram ou non.
	â€¢	Permet une montÃ©e en charge progressive vers un systÃ¨me de chat enrichi Ã  lâ€™avenir.
	â€¢	Conversation dÃ©clenchÃ©e automatiquement via le lien sans action manuelle complexe.
	â€¢	Permet au proposeur dâ€™agir en autonomie aprÃ¨s acceptation.

== 2. Modifications backend

=== 2.1. Base de donnÃ©es

Ajout de la colonne suivante dans la table users :
	â€¢	telegram_username : VARCHAR(255) (optionnel)

=== 2.2. Routes mises Ã  jour
	â€¢	PUT /interests/:id :
	â€¢	Envoie dans la socket telegram_username en plus des coordonnÃ©es classiques.
	â€¢	GET /interests/received/:userId :
	â€¢	Renvoie le telegram_username de lâ€™intÃ©ressÃ©.

=== 2.3. Nouvelle route utilisateur
	â€¢	PUT /users/:id/telegram :
	â€¢	Permet de mettre Ã  jour le telegram_username depuis le front, dans lâ€™espace profil.

== 3. Modifications frontend

=== 3.1. ParamÃ©trage utilisateur

Un nouveau champ â€œNom dâ€™utilisateur Telegramâ€ a Ã©tÃ© ajoutÃ© dans lâ€™espace â€œProfilâ€, dans une section dÃ©diÃ©e intitulÃ©e Contact et notifications.
	â€¢	Ce champ est affichÃ© uniquement si lâ€™utilisateur ne lâ€™a pas encore renseignÃ©.
	â€¢	Il permet de sauvegarder le @username pour Ãªtre contactÃ© via Telegram lors de futures demandes.

=== 3.2. Affichage conditionnel

Dans la vue InterestsList :
	â€¢	Si le champ telegram_username est disponible, un lien de contact Telegram est affichÃ©.
	â€¢	Sinon, seules les coordonnÃ©es classiques (email, tÃ©lÃ©phone) sont prÃ©sentÃ©es.

=== 3.3. Encarts dâ€™information

Dans la vue de recherche (rÃ©sultats dâ€™annonces), un encart informatif avertit les utilisateurs que sâ€™ils ne remplissent pas leur telegram_username, ils ne pourront pas Ãªtre contactÃ©s par ce biais.

== 4. AmÃ©liorations secondaires

=== 4.1. UI/UX
	â€¢	RÃ©organisation de lâ€™espace Profil pour mettre en avant les paramÃ¨tres de contact.
	â€¢	AmÃ©lioration de la lisibilitÃ© des coordonnÃ©es sur les cartes dâ€™intÃ©rÃªts.

=== 4.2. Robustesse
	â€¢	Affichage conditionnel Ã©vitant les erreurs si Telegram nâ€™est pas renseignÃ©.
	â€¢	Meilleure gestion du flux de notification WebSocket (support de telegram_username dans les messages Ã©mis).

== 5. Limitations actuelles
	â€¢	Le bot Telegram nâ€™intervient pas directement (pas dâ€™invitation automatique Ã  des groupes).


== 7. Gestion automatisÃ©e des chatrooms Telegram pour les prÃªts

Dans cette version, nous avons intÃ©grÃ© un bot Telegram permettant de crÃ©er automatiquement un chatroom dÃ©diÃ© Ã  chaque nouveau prÃªt, et de le supprimer/archiver automatiquement Ã  la fin du prÃªt.
Cette automatisation vise Ã  fluidifier la communication entre les parties et Ã  garder la plateforme propre en Ã©vitant lâ€™accumulation de groupes inactifs.

=== FonctionnalitÃ©s livrÃ©es
	â€¢	CrÃ©ation automatique dâ€™un groupe Telegram Ã  chaque nouveau prÃªt, via le bot.
	â€¢	Suppression/archivage automatique du chatroom Ã  la fin du prÃªt (fonctionnalitÃ© dÃ©veloppÃ©e dans cette release).
	â€¢	Lorsquâ€™un utilisateur marque le prÃªt comme terminÃ© (en envoyant â€œ/endâ€, â€œTerminÃ©â€ ou â€œFin du prÃªtâ€ dans le groupe), le bot :
	â€¢	Envoie un message de confirmation dans le groupe.
	â€¢	Exclut automatiquement lâ€™utilisateur ayant terminÃ© le prÃªt (sauf sâ€™il est propriÃ©taire du groupe, limitation Telegram).
	â€¢	Archive/supprime le chatroom dans la limite des possibilitÃ©s de lâ€™API Telegram.
	â€¢	Gestion robuste des erreurs : si lâ€™utilisateur nâ€™est plus dans le groupe ou ne peut pas Ãªtre exclu (ex : owner), le bot ignore lâ€™erreur et logue lâ€™Ã©vÃ©nement.
	â€¢	SÃ©curitÃ© : le bot ne peut exclure que les membres non propriÃ©taires et uniquement si les droits Telegram le permettent.

=== DÃ©tail de la fonctionnalitÃ© de suppression (dÃ©veloppÃ©e dans cette release)
	â€¢	Ajout dâ€™un endpoint webhook /webhook qui reÃ§oit les messages Telegram.
	â€¢	DÃ©tection automatique de la fin dâ€™un prÃªt via des mots-clÃ©s ou commandes spÃ©cifiques.
	â€¢	Envoi dâ€™un message dâ€™archivage dans le groupe.
	â€¢	Exclusion automatique de lâ€™utilisateur ayant marquÃ© le prÃªt comme terminÃ©.
	â€¢	Gestion des cas particuliers :
	â€¢	Si lâ€™utilisateur est dÃ©jÃ  exclu : lâ€™erreur est ignorÃ©e.
	â€¢	Si lâ€™utilisateur est propriÃ©taire du groupe : lâ€™exclusion Ã©choue (limite Telegram), lâ€™Ã©vÃ©nement est loguÃ©.
	â€¢	Cette logique garantit que seuls les groupes actifs sont conservÃ©s, et que les utilisateurs ne restent pas dans des groupes inutiles.

=== Flux Utilisateur
	1.	Un utilisateur crÃ©e un prÃªt sur la plateforme.
	2.	Un groupe Telegram est automatiquement crÃ©Ã© via le bot, et les membres concernÃ©s sont ajoutÃ©s.
	3.	Pendant la durÃ©e du prÃªt, les Ã©changes se font dans ce groupe dÃ©diÃ©.
	4.	Ã€ la fin du prÃªt, un membre envoie â€œ/endâ€ ou â€œTerminÃ©â€ dans le groupe.
	5.	Le bot dÃ©tecte la fin du prÃªt, envoie un message de confirmation, exclut lâ€™utilisateur concernÃ©, et archive le groupe.

=== Endpoints et intÃ©gration technique
	â€¢	Webhook /webhook : reÃ§oit les messages Telegram et dÃ©clenche la logique dâ€™archivage/suppression.
	â€¢	Utilisation de lâ€™API Telegram :
	â€¢	sendMessage : pour notifier la fin du prÃªt.
	â€¢	banChatMember : pour exclure lâ€™utilisateur.
	â€¢	Gestion des erreurs : toutes les erreurs sont loguÃ©es, et les cas non critiques (utilisateur dÃ©jÃ  exclu, etc.) sont ignorÃ©s pour garantir la robustesse du service.

=== Limites connues
	â€¢	Le propriÃ©taire du groupe Telegram ne peut pas Ãªtre exclu par le bot (limitation Telegram).
	â€¢	La suppression totale du groupe nâ€™est pas possible via lâ€™API Telegram, seul le nettoyage des membres et lâ€™envoi dâ€™un message dâ€™archivage sont automatisÃ©s.

=== Exemple de sÃ©quence

[plantuml, pret-telegram-archivage, svg]

@startuml
participant â€œUtilisateurâ€ as User
participant â€œGroupe Telegramâ€ as Chat
participant â€œBot Telegramâ€ as Bot

User -> Chat: Envoie â€œ/endâ€ ou â€œTerminÃ©â€
Chat -> Bot: Webhook reÃ§u
Bot -> Chat: Envoie â€œPrÃªt terminÃ©. Ce chat sera archivÃ©.â€
Bot -> Chat: Exclut lâ€™utilisateur du groupe
Bot -> Chat: Envoie un message dâ€™archivage
@enduml

=== BÃ©nÃ©fices
	â€¢	Automatisation : plus besoin de gÃ©rer manuellement les groupes Telegram liÃ©s aux prÃªts.
	â€¢	PropretÃ© de la plateforme : suppression automatique des groupes inactifs.
	â€¢	ExpÃ©rience utilisateur : les utilisateurs sont notifiÃ©s de la clÃ´ture du prÃªt et exclus du groupe sans intervention manuelle.
	â€¢	Robustesse : gestion des erreurs et des cas limites pour Ã©viter les blocages.

Cette release marque une Ã©tape clÃ© dans lâ€™intÃ©gration de la messagerie instantanÃ©e Ã  la gestion des prÃªts, tout en assurant un nettoyage automatique des groupes Ã  la fin de chaque transaction.